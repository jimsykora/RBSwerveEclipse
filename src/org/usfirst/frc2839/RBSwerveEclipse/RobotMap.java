
package org.usfirst.frc2839.RBSwerveEclipse;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.TalonSRX;
import edu.wpi.first.wpilibj.VictorSP;
import edu.wpi.first.wpilibj.Victor;
import edu.wpi.first.wpilibj.smartdashboard.*;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
    // For example to map the left and right motors, you could define the
    // following variables to use with your drivetrain subsystem.
    // public static int leftMotor = 1;
    // public static int rightMotor = 2;
    
    // If you are using multiple modules, make sure to define both the port
    // number and the module. For example you with a rangefinder:
    // public static int rangefinderPort = 1;
    // public static int rangefinderModule = 1;
    public static AnalogInput lFSPIDSubsystemLFSPot;
    public static SpeedController lFSPIDSubsystemLFSSpeedController;
    public static Encoder lFDPIDSubsystemLFDEncoder;
    public static SpeedController lFDPIDSubsystemLFDSpeedController;
    public static AnalogInput rFSPIDSubsystemRFSPot;
    public static SpeedController rFSPIDSubsystemRFSSpeedController;
    public static Encoder rFDPIDSubsystemRFDEncoder;
    public static SpeedController rFDPIDSubsystemRFDSpeedController;
    public static AnalogInput rRSPIDSubsystemRRSPot;
    public static SpeedController rRSPIDSubsystemRRSSpeedController;
    public static Encoder rRDPIDSubsystemRRDEncoder;
    public static SpeedController rRDPIDSubsystemRRDSpeedController;
    public static AnalogInput lRSPIDSubsystemLRSPot;
    public static SpeedController lRSPIDSubsystemLRSSpeedController;
    public static Encoder lRDPIDSubsystemLRDEncoder;
    public static SpeedController lRDPIDSubsystemLRDSpeedController;

    public static double offsetLFS;  // offset the pot value to align steering
    public static double offsetRFS;  // offset the pot value to align steering
    public static double offsetRRS;  // offset the pot value to align steering
    public static double offsetLRS;  // offset the pot value to align steering
    public static double spinLFS;  // angle to align steering for spin command
    public static double spinRFS;  // angle to align steering for spin command
    public static double spinRRS;  // angle to align steering for spin command
    public static double spinLRS;  // angle to align steering for spin command
    public static double frbiasLFS; // //voltage adjust to compensate for gear & chain backlash biases
    public static double frbiasRFS; // //voltage adjust to compensate for gear & chain backlash biases
    public static double frbiasRRS; // //voltage adjust to compensate for gear & chain backlash biases
    public static double frbiasLRS; // //voltage adjust to compensate for gear & chain backlash biases
    //public static double min_count_rate;
    
    public static void init() {
        lFSPIDSubsystemLFSPot = new AnalogInput(0);
        LiveWindow.addSensor("LFS PID Subsystem", "LFS Pot", lFSPIDSubsystemLFSPot);      
        lFSPIDSubsystemLFSSpeedController = new VictorSP(1);
        LiveWindow.addActuator("LFS PID Subsystem", "LFS Speed Controller", (VictorSP) lFSPIDSubsystemLFSSpeedController);
        
        lFDPIDSubsystemLFDEncoder = new Encoder(0, 1, true, EncodingType.k1X);//true false foe direction
        LiveWindow.addSensor("LFD PID Subsystem", "LFD  Encoder", lFDPIDSubsystemLFDEncoder);
        lFDPIDSubsystemLFDEncoder.setDistancePerPulse(.0071);//(3*3.14*30/48*16/44)/300=.0071
        lFDPIDSubsystemLFDEncoder.setPIDSourceType(PIDSourceType.kRate);
        lFDPIDSubsystemLFDSpeedController = new VictorSP(0);
        LiveWindow.addActuator("LFD PID Subsystem", "LFD Speed Controller", (VictorSP) lFDPIDSubsystemLFDSpeedController);
        
        rFSPIDSubsystemRFSPot = new AnalogInput(2);
        LiveWindow.addSensor("RFS PID Subsystem", "RFS Pot", rFSPIDSubsystemRFSPot);        
        rFSPIDSubsystemRFSSpeedController = new VictorSP(5);
        LiveWindow.addActuator("RFS PID Subsystem", "RFS Speed Controller", (VictorSP) rFSPIDSubsystemRFSSpeedController);
        
        rFDPIDSubsystemRFDEncoder = new Encoder(4, 5, true, EncodingType.k1X);//true false foe direction
        LiveWindow.addSensor("RFD PID Subsystem", "RFD  Encoder", rFDPIDSubsystemRFDEncoder);
        rFDPIDSubsystemRFDEncoder.setDistancePerPulse(.0071);//(3*3.14*30/48*16/44)/300=.0071
        rFDPIDSubsystemRFDEncoder.setPIDSourceType(PIDSourceType.kRate);
        rFDPIDSubsystemRFDSpeedController = new VictorSP(4);
        LiveWindow.addActuator("RFD PID Subsystem", "RFD Speed Controller", (VictorSP) rFDPIDSubsystemRFDSpeedController);
        
        rRSPIDSubsystemRRSPot = new AnalogInput(3);
        LiveWindow.addSensor("RRS PID Subsystem", "RRS Pot", rRSPIDSubsystemRRSPot);    
        rRSPIDSubsystemRRSSpeedController = new VictorSP(6);
        LiveWindow.addActuator("RRS PID Subsystem", "RRS Speed Controller", (VictorSP) rRSPIDSubsystemRRSSpeedController);
        
        rRDPIDSubsystemRRDEncoder = new Encoder(6, 7, true, EncodingType.k1X);//true false foe direction
        LiveWindow.addSensor("RRD PID Subsystem", "RRD  Encoder", rRDPIDSubsystemRRDEncoder);
        rRDPIDSubsystemRRDEncoder.setDistancePerPulse(.0071);//(3*3.14*30/48*16/44)/300=.0071
        rRDPIDSubsystemRRDEncoder.setPIDSourceType(PIDSourceType.kRate);
        rRDPIDSubsystemRRDSpeedController = new VictorSP(7);
        LiveWindow.addActuator("RRD PID Subsystem", "RRD Speed Controller", (VictorSP) rRDPIDSubsystemRRDSpeedController);
        
        lRSPIDSubsystemLRSPot = new AnalogInput(1);
        LiveWindow.addSensor("LRS PID Subsystem", "LRS Pot", lRSPIDSubsystemLRSPot);        
        lRSPIDSubsystemLRSSpeedController = new VictorSP(2);
        LiveWindow.addActuator("LRS PID Subsystem", "LRS Speed Controller", (VictorSP) lRSPIDSubsystemLRSSpeedController);
        
        lRDPIDSubsystemLRDEncoder = new Encoder(2, 3, true, EncodingType.k1X);//true false foe direction
        LiveWindow.addSensor("LRD PID Subsystem", "LRD  Encoder", lRDPIDSubsystemLRDEncoder);
        lRDPIDSubsystemLRDEncoder.setDistancePerPulse(.0071);//(3*3.14*30/48*16/44)/300=.0071
        lRDPIDSubsystemLRDEncoder.setPIDSourceType(PIDSourceType.kRate);
        lRDPIDSubsystemLRDSpeedController = new VictorSP(3);
        LiveWindow.addActuator("LRD PID Subsystem", "LRD Speed Controller", (VictorSP) lRDPIDSubsystemLRDSpeedController);
            
    //gyroRangefinderGyro1 = new Gyro(1, 2); //gyros must be in either port 1 or 2
    //gyroRangefinderRangefinder = new AnalogInput(1, 1);
    offsetLFS = 2.208; //raw voltage when wheels are mechanically aligned, sprockets facing right
    offsetRFS = 0.657; //raw voltage when wheels are mechanically aligned, sprockets facing right
    offsetRRS = 3.411; //raw voltage when wheels are mechanically aligned, sprockets facing right
    offsetLRS = 4.706; //raw voltage when wheels are mechanically aligned, sprockets facing right
    spinLFS = 1.875; //raw voltage added to spin about center of square base, if > 2.5, subtract 5. Increase # to increase CCW steer
    spinRFS = 0.625; //raw voltage added to spin about center of square base, if > 2.5, subtract 5.
    spinRRS = 4.375-5; //raw voltage added to spin about center of square base, if > 2.5, subtract 5.
    spinLRS = 3.125-5; //raw voltage added to spin about center of square base, if > 2.5, subtract 5.
    frbiasLFS = .013; //voltage adjust to compensate for gear & chain backlash biases, check backlash @ mech align, divide by 2
    frbiasRFS = .015; //voltage adjust to compensate for gear & chain backlash biases, check backlash @ mech align, divide by 2
    frbiasRRS = .012; //voltage adjust to compensate for gear & chain backlash biases, check backlash @ mech align, divide by 2
    frbiasLRS = .014; //voltage adjust to compensate for gear & chain backlash biases,  check backlash @ mech align, divide by 2  

    }
}
